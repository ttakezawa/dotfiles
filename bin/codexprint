#!/bin/bash
# codexprint - make `codex exec` easy to use in pipelines on macOS.
# Example:
#   eza --help | codexprint 日本語にして
#   cat README.md | codexprint -m gpt-5-codex-mini 箇条書きで要約
#   echo "test" | codexprint -p myprofile -c key=value --search 解説して
#
# 仕様:
# - 先頭のオプションはそのまま `codex exec` に転送
#   (-m/--model, -c/--config, -p/--profile, --search, --enable/--disable)
# - 最初の非オプション（または `--` の後ろ）以降は PROMPT として扱う
# - stdin の内容とプロンプトを組み合わせて `codex exec` に渡す
# - パイプが無い場合はプロンプトのみで実行
# - ユーザー指定が無ければ `--enable web_search_request` を自動付与

set -eo pipefail

if ! command -v codex >/dev/null 2>&1; then
  echo "codexprint: 'codex' command not found. Please install/ensure it's on PATH." >&2
  exit 127
fi

if [[ "${1:-}" == "-h" || "${1:-}" == "--help" ]]; then
  cat <<'EOF'
Usage:
  <producer> | codexprint [codex-options...] [--] [PROMPT...]

Supported options:
  -m, --model <MODEL>         Specify the model to use
  -c, --config <key=value>    Set configuration key-value pair
  -p, --profile <PROFILE>     Use specified configuration profile
  --search                    Enable search functionality

Examples:
  eza --help | codexprint 日本語にして
  cat file.txt | codexprint -m gpt-5-codex-mini 要点を3つに要約
  echo "test" | codexprint -p myprofile -c key=value 解説して
  codexprint -m gpt-5-codex-mini Hello World

Notes:
  - オプション値が '-' で始まる場合は、`--` で明示的に区切ってください。
EOF
  exit 0
fi

extract_last_agent_message() {
  local file="$1"
  if command -v python3 >/dev/null 2>&1; then
    python3 - "$file" <<'PY'
import json, sys
path = sys.argv[1]

def to_text(item):
    text = item.get("text")
    if isinstance(text, str):
        return text
    if isinstance(text, list):
        return "\n".join(str(t) for t in text if t is not None)
    content = item.get("content") or []
    parts = []
    for block in content:
        txt = block.get("text")
        if isinstance(txt, str):
            parts.append(txt)
    return "\n".join(parts)

last = ""
with open(path) as fh:
    for line in fh:
        line = line.strip()
        if not line:
            continue
        try:
            data = json.loads(line)
        except json.JSONDecodeError:
            continue
        if data.get("type") != "item.completed":
            continue
        item = data.get("item") or {}
        if item.get("type") != "agent_message":
            continue
        candidate = to_text(item)
        if candidate:
            last = candidate
if last:
    print(last)
PY
    return
  fi

  if command -v jq >/dev/null 2>&1; then
    jq -sr '
      map(select(.type=="item.completed" and .item.type=="agent_message") | .item.text // empty)
      | if length>0 then last else "" end
    ' "$file"
    return
  fi

  local last=""
  while IFS= read -r line; do
    if echo "$line" | grep -q '"type":"item.completed"' && echo "$line" | grep -q '"type":"agent_message"'; then
      last="$line"
    fi
  done < "$file"
  if [[ -n "$last" ]]; then
    echo "$last" | sed -n 's/.*"text":"\(.*\)"}}/\1/p' | sed 's/\\n/\n/g; s/\\t/\t/g; s/\\"/"/g; s/\\\\/\\/g'
  fi
}

# ---- stdin を読み取り（パイプ無しなら空） ----
stdin_content=""
if [[ ! -t 0 ]]; then
  stdin_content="$(cat)"    # パイプ/リダイレクト -> 内容を変数に保存
fi

# ---- 先頭のオプションを収集（値つき対応） ----
declare -a opts=()
add_web_search=true
while (($#)); do
  case "$1" in
    --) shift; break ;;                               # オプション終端
    --model=*|--config=*|--profile=*|-m=*|-c=*|-p=*) # --long=VAL / -m=VAL
      opts+=("$1"); shift ;;
    --search)                                         # boolean option
      add_web_search=false
      opts+=("$1"); shift ;;
    --enable|--disable)
      if (($#>=2)) && [[ "$2" != -* ]]; then
        add_web_search=false
        opts+=("$1" "$2"); shift 2
      else
        echo "codexprint: option '$1' requires an argument" >&2
        exit 1
      fi
      ;;
    --enable=*|--disable=*)
      add_web_search=false
      opts+=("$1"); shift ;;
    --model|--config|--profile|-m|-c|-p)              # --long [VAL] / -m [VAL]
      if (($#>=2)) && [[ "$2" != -* ]]; then
        opts+=("$1" "$2"); shift 2
      else
        echo "codexprint: option '$1' requires an argument" >&2
        exit 1
      fi
      ;;
    -*)
      echo "codexprint: unsupported option '$1'" >&2
      exit 1
      ;;
    *)  break ;;
  esac
done

# ---- プロンプトを構築 ----
user_prompt="$*"  # 残りの引数を全てプロンプトとして結合

# stdin の内容がある場合は、見やすい形式でプロンプトと組み合わせる
if [[ -n "$stdin_content" ]]; then
  combined_prompt="Follow the user's instructions and output only the result.

User instruction: ${user_prompt}

\`\`\`
${stdin_content}
\`\`\`"
else
  combined_prompt="Follow the user's instructions and output only the result.

User instruction: ${user_prompt}"
fi

# ---- 実行 ----
# --json オプションで JSONL 出力を取得し、最後のアシスタントメッセージのみを抽出
# --skip-git-repo-check を常に付与してリポジトリチェックを抑制
declare -a cmd=(codex exec --json --skip-git-repo-check)
if "$add_web_search"; then
  cmd+=(--enable web_search_request)
fi
((${#opts[@]})) && cmd+=("${opts[@]}")
# PROMPT は stdin から渡すため、明示的に '-' を指定
cmd+=(-)

# プロンプトは stdin から渡す（引数ではなく）
# 一時ファイルに出力を保存
tmpout="$(mktemp -t codexprint_out.XXXXXX)"
trap 'rm -f "$tmpout"' EXIT

if ! echo "$combined_prompt" | "${cmd[@]}" > "$tmpout"; then
  status=$?
  echo "codexprint: codex exec failed (exit code $status). Raw output:" >&2
  cat "$tmpout" >&2
  exit "$status"
fi

extract_last_agent_message "$tmpout"
